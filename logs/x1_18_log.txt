Magma V2.28-3     Wed Jun  5 2024 14:35:30 on euler    [Seed = 2105229481]
Type ? for help.  Type <Ctrl>-D to quit.
> /*
>   This script runs the computations for X1(18) described in Section 3 of the paper
> */
>
> // We only care about the twists of positive rank; see Corollary 3.7 of the paper
> // By results of Krumm we need d > 0 and d = 1 or 9 mod 24, this is Prop. 3.1 of the paper
>
> positive_rank := [-9791, -9489, -9434, -9431, -9206, -9201, -9031, -8999, -8979, -8966, -8858, -8639, -8627, -8449, -8327, -8243, -8123, -7909, -7847, -7671, -7487, -7447, -7323, -7319, -7199, -707\
1, -7010, -6911, -6749, -6645, -6623, -6611, -6479, -6323, -6263, -6191, -6187, -6159, -6047, -5963, -5885, -5883, -5543, -5295, -5255, -5207, -5165, -5095, -4895, -4751, -4694, -4679, -4535, -4521, \
-4515, -4103, -4031, -3881, -3815, -3743, -3371, -3299, -3239, -3149, -3135, -3095, -3041, -2915, -2861, -2834, -2759, -2579, -2495, -2406, -2378, -2279, -2183, -2087, -2055, -2037, -1991, -1943, -19\
41, -1931, -1871, -1853, -1851, -1658, -1623, -1517, -1511, -1509, -1455, -1407, -1358, -1335, -1223, -1221, -1191, -1151, -1118, -1046, -1011, -935, -863, -817, -807, -794, -654, -647, -627, -623, -\
591, -542, -533, -503, -497, -431, -426, -407, -402, -287, -267, -215, -143, -139, -129, -110, -71, -59, 1, 33, 43, 109, 123, 137, 253, 267, 337, 353, 417, 457, 469, 497, 654, 681, 697, 858, 871, 985\
, 1009, 1122, 1142, 1261, 1293, 1294, 1329, 1342, 1345, 1353, 1509, 1649, 1699, 1726, 1727, 1761, 1793, 1993, 2155, 2310, 2314, 2329, 2557, 2589, 2759, 2833, 2841, 2913, 2962, 3082, 3281, 3282, 3442,\
 3485, 3489, 3493, 3637, 3741, 3769, 3806, 3927, 4081, 4145, 4529, 4615, 4642, 4729, 5137, 5149, 5161, 5281, 5369, 5379, 5659, 5878, 6001, 6082, 6217, 6490, 6601, 6729, 6819, 7057, 7234, 7242, 7321, \
7359, 7369, 7469, 7521, 7655, 7705, 7926, 8205, 8241, 8274, 8339, 8382, 8409, 8421, 8633, 8729, 8965, 8989, 9042, 9049, 9097, 9137, 9183, 9431, 9483, 9586, 9705, 9726, 9790, 9869, 9890, 9913, 9969];
> positive_rank2 := [d : d in positive_rank | (d gt 0) and (d mod 8 eq 1) and (d mod 3 ne 2)];
>
> //y^2=f is isomorphic to  X_1(18)
> R<x> := PolynomialRing(Rationals());
> f := R![1, 2, 5, 10, 10, 4, 1];
>
> // The following  code runs the Two-cover descent routine, see Section 3.3 of the paper
> empty_selmer := [];
> nonempty_selmer := [];
> for d in positive_rank2 do
for>   print(d);
for>   C := HyperellipticCurve(d*f);
for>   Sel2 := TwoCoverDescent(C);
for>   if #Sel2 eq 0 then
for|if>     Append(~empty_selmer, d);
for|if>   else
for|if>     Append(~nonempty_selmer, d);
for|if>   end if;
for> end for;
1
33
337
417
457
681
697
985
1009
1329
1345
1353
1761
1993
2329
2833
2841
2913
3489
3769
4081
4729
5137
5161
5281
6001
6217
6601
6729
7057
7321
7369
7521
7705
8241
8409
9049
9097
9705
9913
9969
> print(empty_selmer);
[ 417, 697, 985, 1345, 1353, 2329, 3489, 4081, 5137, 5161, 6001, 6601, 6729,
7521, 7705, 8409, 9097, 9705, 9913 ]
> print(nonempty_selmer);
[ 1, 33, 337, 457, 681, 1009, 1329, 1761, 1993, 2833, 2841, 2913, 3769, 4729,
5281, 6217, 7057, 7321, 7369, 8241, 9049, 9969 ]
> print(#nonempty_selmer);
22
>
> // The following code just searches for points on the output of the previous\
 step
> extra_point_ds := [];
> extra_point_list := [* *];
> unsolved := [];
> for d in nonempty_selmer do
for>   C:=HyperellipticCurve(d*f);
for>   points := Points(C: Bound:=100000);
for>   if #points gt 0 then
for|if>     print "====", d, #points, "====";
for|if>     print points;
for|if>     Append(~extra_point_list, <d, points>);
for|if>     Append(~extra_point_ds, d);
for|if>   else
for|if>     Append(~unsolved, d);
for|if>   end if;
for> end for;
==== 1 6 ====
{@ (1 : -1 : 0), (1 : 1 : 0), (-1 : -1 : 1), (-1 : 1 : 1), (0 : -1 : 1), (0 : 1
: 1) @}
==== 33 6 ====
{@ (1 : -33 : 1), (1 : 33 : 1), (-2 : -33 : 1), (-2 : 33 : 1), (-1 : -33 : 2),
(-1 : 33 : 2) @}
==== 337 6 ====
{@ (1 : -337 : 2), (1 : 337 : 2), (-3 : -337 : 1), (-3 : 337 : 1), (-2 : -337 :
3), (-2 : 337 : 3) @}
==== 457 6 ====
{@ (2 : -457 : 1), (2 : 457 : 1), (-3 : -457 : 2), (-3 : 457 : 2), (-1 : -457 :
3), (-1 : 457 : 3) @}
==== 1009 6 ====
{@ (3 : -11099 : 5), (3 : 11099 : 5), (-8 : -11099 : 3), (-8 : 11099 : 3), (-5 :
-11099 : 8), (-5 : 11099 : 8) @}
==== 1993 6 ====
{@ (1 : -1993 : 3), (1 : 1993 : 3), (-4 : -1993 : 1), (-4 : 1993 : 1), (-3 :
-1993 : 4), (-3 : 1993 : 4) @}
==== 2833 6 ====
{@ (3 : -2833 : 1), (3 : 2833 : 1), (-4 : -2833 : 3), (-4 : 2833 : 3), (-1 :
-2833 : 4), (-1 : 2833 : 4) @}
==== 7369 6 ====
{@ (2 : -7369 : 3), (2 : 7369 : 3), (-5 : -7369 : 2), (-5 : 7369 : 2), (-3 :
-7369 : 5), (-3 : 7369 : 5) @}
==== 8241 6 ====
{@ (1 : -8241 : 4), (1 : 8241 : 4), (-5 : -8241 : 1), (-5 : 8241 : 1), (-4 :
-8241 : 5), (-4 : 8241 : 5) @}
==== 9049 6 ====
{@ (3 : -9049 : 2), (3 : 9049 : 2), (-5 : -9049 : 3), (-5 : 9049 : 3), (-2 :
-9049 : 5), (-2 : 9049 : 5) @}
> print(extra_point_ds);
[ 1, 33, 337, 457, 1009, 1993, 2833, 7369, 8241, 9049 ]
> // These are the values of d for which we needed to run the MW sieve.
> // The reader may see it in the log file (`x1_18_log.txt`).
> print(unsolved);
[ 681, 1329, 1761, 2841, 2913, 3769, 4729, 5281, 6217, 7057, 7321, 9969 ]
>

Total time: 90.180 seconds, Total memory usage: 117.19MB
